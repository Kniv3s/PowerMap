function toBinary ($dottedDecimal){
	$dottedDecimal.split(".") | %{$binary=$binary + $([convert]::toString($_,2).padleft(8,"0"))}
	return $binary
}
function toDottedDecimal ($binary){
	do {$dottedDecimal += "." + [string]$([convert]::toInt32($binary.substring($j,8),2)); $j+=8 } while ($j -le 24)
	return $dottedDecimal.substring(1)
}
function PowerMap {
    <#
		.SYNOPSIS
		Scan IP-Addresses, Ports, and HostNames		.DESCRIPTION
		Scan for IP-Addresses, HostNames, and open Ports in your Network.		.PARAMETER StartAddress
		StartAddress Range		.PARAMETER EndAddress
		EndAddress Range		.PARAMETER ResolveHost
		Resolve HostName		.PARAMETER ScanPort
		Perform a PortScan		.PARAMETER ScanType
		The type of scan to do. Currently on tcp and udp are supported. TCP connect scan is default.		.PARAMETER UDPTimeOut
		The amount of time to wait to decide if a UDP port is open. If a non-UDP scan is used, value is ignored. Default is 5000ms.		.PARAMETER Ports
		Ports That should be scanned, default values are: 21,22,23,53,69,71,80,98,110,139,111,
		389,443,445,1080,1433,2001,2049,3001,3128,5222,6667,6868,7777,7878,8080,1521,3306,3389,
		5801,5900,5555,5901		.PARAMETER TimeOut
		Time (in MilliSeconds) before TimeOut, Default set to 100.		.PARAMETER Subnet
		A subnet or subnetmask to scan over. When used with (or without) EndAddress; will override
		StartAddress with first address in subnet and override EndAddress with last address in subnet
	#>
	Param(
        [parameter(Position = 0, ParameterSetName="AddressList")]
		[ValidatePattern("\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b")]
		[string[]]
        $AddressList,
        [parameter(Position = 0, ParameterSetName="Network")]
        [ValidatePattern("\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(([\\,/]\d{1,2})|-\.{0,1}\d{1,3}(\.\d{1,3}){0,3})\b")]
        [string]
        $Network,
		[parameter(Position = 0, ParameterSetName="AddressRange")]
		[parameter(Position = 0, ParameterSetName="Subnet")]
		[ValidatePattern("\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b")]
		[string]
        $StartAddress,
        [parameter(Position = 1, ParameterSetName="AddressRange")]
		[string]
        $EndAddress,
        [parameter(Position = 1, ParameterSetName="Subnet")]
		[string]
        $Subnet,
		[switch]
        $ResolveHost,
		[switch]
        $TCPScan,
        [switch]
        $UDPScan,
		[int]
        $UDPTimeOut = 5000,
		[int[]]
        $Ports = @(21,22,23,53,69,71,80,88,110,139,111,389,443,445,1080,1433,1434,1521,2001,2049,3001,3128,3306,3389,5222,5555,5801,5900,5901,6667,6868,7777,7878,8080),
		[int]
        $TimeOut = 100
	)
	Begin {
		$ping = New-Object System.Net.Networkinformation.Ping
		$hosts = @()
        $ret = @()
        if ($PSCmdlet.ParameterSetName -eq "AddressList") {
            $hosts = $AddressList
        } else {
            if ($PSCmdlet.ParameterSetName -eq "Network") {
                if ($Network.IndexOf("-") -ne -1){
                    $StartAddress = $Network.Split('-')[0]
                    $EndAddr = $Network.Split('-')[1]
                    if ($EndAddr.StartsWith(".")){
                        $EndAddr = $EndAddr.Substring(1)
                    }
                    $t = 3 - $EndAddr.Split('.').Count
                    $EndAddr = $StartAddress.Split('.')[0..$t] + $EndAddr.Split('.')
                    $EndAddress = $EndAddr[0]
                    for ($i = 1; $i -lt 4; $i++) {
                        $EndAddress += "." + $EndAddr[$i]
                    }
                } else {
                    $ipBinary = toBinary([String]($Network.Split('\').Split('/')[0]))
                    $Subnet = [int]($Network.Split('\').Split('/')[1])
                    $StartAddress = toDottedDecimal($ipBinary.substring(0,$Subnet).padright(31,"0") + "1")
			        $EndAddress = toDottedDecimal($ipBinary.substring(0,$Subnet).padright(31,"1") + "0")
                }
            } elseif ($PSCmdlet.ParameterSetName -eq "AddressRange") {
			    if ($Subnet) {
				    $ipBinary = toBinary($StartAddress)
				    if ($Subnet.StartsWith("/") -or $Subnet.StartsWith("\")) {
					    $Subnet = $Subnet.Substring(1)
				    }
                    $Subnet = [int]$Subnet
				    $StartAddress = toDottedDecimal($ipBinary.substring(0,$Subnet).padright(31,"0") + "1")
				    $EndAddress = toDottedDecimal($ipBinary.substring(0,$Subnet).padright(31,"1") + "0")
			    }
            }
            if (!$EndAddress) {
			    $hosts += $StartAddress
		    } else {
                $Start = [convert]::ToUInt32( $(toBinary($StartAddress)), 2 )
                $End = [convert]::ToUInt32( $(toBinary($EndAddress)), 2)
		        for ($i = $start; $i -le $End; $i++){
                    $t = [convert]::toString($i,2).padleft(32,"0")
                    $hosts += toDottedDecimal( $t )
		        }
            }
        }
	}
	Process {
		for ($n = 0; $n -lt $hosts.Count; $n++) {
            $h = $hosts[$n]
			$d = $h.Split(".")[3]
			if ($EndAddress) {
				write-progress -activity PingSweep -status "$h" -percentcomplete (($n/$hosts.Count) * 100)
			}
			$pingStatus = $ping.Send("$h",$TimeOut)
			if ($pingStatus.Status -eq "Success") {
				if($ResolveHost) {
					if ($EndAddress){
						write-progress -activity ResolveHost -status "$h" -percentcomplete (($n/$hosts.Count)  * 100) -Id 1
					}
					$getHostEntry = [Net.DNS]::BeginGetHostEntry($pingStatus.Address, $null, $null)
				}
                if ($TCPScan -or $UDPScan) {
				    for ($i = 1; $i -le $ports.Count;$i++) {
					    $port = $ports[($i-1)]
					    write-progress -activity PortScan -status "$h" -percentcomplete (($i/($Ports.Count)) * 100) -Id 2
					    if ($TCPScan) {
                            $OpenTCPPorts = @()
                            $ClosedTCPPorts = @()
						    $client = New-Object System.Net.Sockets.TcpClient
						    $beginConnect = $client.BeginConnect($pingStatus.Address,$port,$null,$null)
						    if ($client.Connected) {
							    $OpenTCPPorts += $port
						    } else {
							    # Wait
							    Start-Sleep -Milli $TimeOut
							    if($client.Connected) {
								    $OpenTCPPorts += $port
							    } else {
								    $ClosedTCPPorts += $port
							    }
						    }
						    $client.Close()
					    }
					    if ($UDPScan) {
                            $OpenUDPPorts = @()
                            $ClosedUDPPorts = @()
						    $client = new-Object system.Net.Sockets.Udpclient
						    $client.client.ReceiveTimeout = $UDPTimeOut
						    $client.Connect($pingStatus.Address,$port)
						    $a = new-Object System.Text.ASCIIEncoding
						    $byte = $a.GetBytes("$(Get-Date)")
						    [void]$client.Send($byte,$byte.length)
						    $remoteendpoint = New-Object system.net.ipendpoint([system.net.ipaddress]::Any,0)
						    Try {
							    $receivebytes = $client.Receive([ref]$remoteendpoint) 
							    [string]$returndata = $a.GetString($receivebytes)
							    If ($returndata) {
								    $OpenUDPPorts += $port
							    }
						    } Catch {
							    If ($Error[0].ToString() -match "\bRespond after a period of time\b") {
								    $OpenUDPPorts += $port
							    } ElseIf ($Error[0].ToString() -match "forcibly closed by the remote host" ) { 
								    $ClosedUDPPorts += $port
							    } Else {
                                    Write-Host $Error[0].ToString()
                                }
						    } Finally {
							    $client.close()
						    }
					    } 
				    }
                }
			}
			if($ResolveHost) {
				$hostName = ([Net.DNS]::EndGetHostEntry([IAsyncResult]$getHostEntry)).HostName
			}
			# Return Object
			$ret += New-Object PSObject -Property @{
				IPAddress = "$h";
				HostName = $hostName;
				OpenTCPPorts = $OpenTCPPorts;
				ClosedTCPPorts = $ClosedTCPPorts;
                OpenUDPPorts = $OpenUDPPorts;
				ClosedUDPPorts = $ClosedUDPPorts;
			}
		}
	}
	End {
        return $ret
	}
}
