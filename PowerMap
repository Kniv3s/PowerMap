function toBinary ($dottedDecimal){
	$dottedDecimal.split(".") | %{$binary=$binary + $([convert]::toString($_,2).padleft(8,"0"))}
	return $binary
}
function toDottedDecimal ($binary){
	do {$dottedDecimal += "." + [string]$([convert]::toInt32($binary.substring($i,8),2)); $i+=8 } while ($i -le 24)
	return $dottedDecimal.substring(1)
}
function PowerMap {
	Param(
		[parameter(Mandatory = $true, Position = 0)]
		[ValidatePattern("\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b")]
		[string]$StartAddress,
		[string]$EndAddress,
		[string]$Subnet,
		[switch]$ResolveHost,
		[switch]$ScanPort,
		[string]$ScanType = "tcp",
		[int]$UDPTimeOut = 5000,
		[int[]]$Ports = @(21,22,23,53,69,71,80,88,110,139,111,389,443,445,1080,1433,1434,2001,2049,3001,3128,5222,6667,6868,7777,7878,8080,1521,3306,3389,5801,5900,5555,5901),
		[int]$TimeOut = 100
	)
	Begin {
		$ping = New-Object System.Net.Networkinformation.Ping
		$hosts = @()
        $ret = @()
		if (!$EndAddress -and !$Subnet) {
			$hosts += $StartAddress
		} else {
			if ($Subnet) {
				$ipBinary = toBinary($StartAddress)
				if ($Subnet.StartsWith("/") -or $Subnet.StartsWith("\")) {
					$netBits = $Subnet.Substring(1)
				} else {
					$netBinary = toBinary($Subnet)
					$netBits=$smBinary.indexOf("0")
				}
				$StartAddress = toDottedDecimal($ipBinary.substring(0,$netBits).padright(31,"0") + "1")
				$EndAddress = toDottedDecimal($ipBinary.substring(0,$netBits).padright(31,"1") + "0")
			}
			foreach($a in ($StartAddress.Split(".")[0]..$EndAddress.Split(".")[0])) {
				foreach($b in ($StartAddress.Split(".")[1]..$EndAddress.Split(".")[1])) {
					foreach($c in ($StartAddress.Split(".")[2]..$EndAddress.Split(".")[2])) {
						foreach($d in ($StartAddress.Split(".")[3]..$EndAddress.Split(".")[3])) {
							$hosts += "$a.$b.$c.$d"
						}
					}
				}
			}
		}
		$supported = @("tcp", "udp")
		if ( -Not $supported.contains($ScanType.ToLower())) {
			Write-Error "Unsupported port scan type. Only Host Discovery Performed"
			$ScanPort = 0
		}
	}
	Process {
		
		foreach ($h in $hosts) {
			$d = $h.Split(".")[3]
			if ($EndAddress) {
				write-progress -activity PingSweep -status "$h" -percentcomplete (($d/($EndAddress.Split(".")[3])) * 100)
			}
			$pingStatus = $ping.Send("$h",$TimeOut)
			if($pingStatus.Status -eq "Success") {
				if($ResolveHost) {
					if ($EndAddress){
						write-progress -activity ResolveHost -status "$h" -percentcomplete (([int]$d/[int]($EndAddress.Split(".")[3])) * 100) -Id 1
					}
					$getHostEntry = [Net.DNS]::BeginGetHostEntry($pingStatus.Address, $null, $null)
				}
				if($ScanPort) {
					$openPorts = @()
					$closedPorts = @()
					for($i = 1; $i -le $ports.Count;$i++) {
						$port = $Ports[($i-1)]
						write-progress -activity PortScan -status "$h" -percentcomplete (($i/($Ports.Count)) * 100) -Id 2
						switch($ScanType.ToLower()) {
							"tcp" {
								$client = New-Object System.Net.Sockets.TcpClient
								$beginConnect = $client.BeginConnect($pingStatus.Address,$port,$null,$null)
								if($client.Connected) {
									$openPorts += $port
								} else {
									# Wait
									Start-Sleep -Milli $TimeOut
									if($client.Connected) {
										$openPorts += $port
									} else {
										$closedPorts += $port
									}
								}
								$client.Close()
							}
							"udp" {
								$client = new-Object system.Net.Sockets.Udpclient
								$client.client.ReceiveTimeout = $UDPTimeOut
								$client.Connect($pingStatus.Address,$port)
								$a = new-Object System.Text.ASCIIEncoding
								$byte = $a.GetBytes("$(Get-Date)")
								[void]$client.Send($byte,$byte.length)
								$remoteendpoint = New-Object system.net.ipendpoint([system.net.ipaddress]::Any,0)
								Try {
									$receivebytes = $client.Receive([ref]$remoteendpoint) 
									[string]$returndata = $a.GetString($receivebytes)
									If ($returndata) {
										$openPorts += $port
									}
								} Catch {
									If ($Error[0].ToString() -match "\bRespond after a period of time\b") {
										$openPorts += $port
									} ElseIf ($Error[0].ToString() -match "forcibly closed by the remote host" ) { 
										$closedPorts += $port
									}
								} Finally {
									$client.close()
								}
							}
						} 
					}
				}
				if($ResolveHost) {
					$hostName = ([Net.DNS]::EndGetHostEntry([IAsyncResult]$getHostEntry)).HostName
				}
				# Return Object
				$ret += New-Object PSObject -Property @{
					IPAddress = "$h";
					HostName = $hostName;
					OpenPorts = $openPorts;
					ClosedPorts = $closedPorts
				}
			}
		}
	}
	End {
        return $ret
	}
}
