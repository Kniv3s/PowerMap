function toBinary ($dottedDecimal){
	$dottedDecimal.split(".") | %{$binary=$binary + $([convert]::toString($_,2).padleft(8,"0"))}
	return $binary
}
function toDottedDecimal ($binary){
	do {$dottedDecimal += "." + [string]$([convert]::toInt32($binary.substring($j,8),2)); $j+=8 } while ($j -le 24)
	return $dottedDecimal.substring(1)
}
function PowerMap {
    <#
	.SYNOPSIS
		Scan IP-Addresses, Ports, and HostNames

    .DESCRIPTION
		Scan for IP-Addresses, HostNames, and open Ports in your Network.

	.PARAMETER StartAddress
		StartAddress Range
    .PARAMETER EndAddress
        A CIDR network range
    .PARAMETER Network
		EndAddress Range
	.PARAMETER ResolveHost
		Resolve HostName
	.PARAMETER TCPScan
		Perform a TCP Syn scan of all listed ports
    .PARAMETER UDPScan
        Perform a UDP scan of all listed ports
	.PARAMETER UDPTimeOut
		The amount of time to wait to decide if a UDP port is open. If a non-UDP scan is used, value is ignored. Default is 5000ms.
	.PARAMETER Ports
		Ports That should be scanned, default values are: 21,22,23,53,69,71,80,98,110,139,111,
		389,443,445,1080,1433,2001,2049,3001,3128,5222,6667,6868,7777,7878,8080,1521,3306,3389,
		5801,5900,5555,5901
	.PARAMETER TimeOut
		Time (in MilliSeconds) before TimeOut, Default set to 100.
	.PARAMETER Subnet
		A subnet or subnetmask to scan over. When used with (or without) EndAddress; will override
		StartAddress with first address in subnet and override EndAddress with last address in subnet
	#>
	Param(
        [parameter(Position = 0, ParameterSetName="AddressList")]
		[ValidatePattern("\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b")]
		[string[]]
        $AddressList,
        [parameter(Position = 0, ParameterSetName="Network")]
        [ValidatePattern("\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(([\\,/]\d{1,2})|-\.{0,1}\d{1,3}(\.\d{1,3}){0,3})\b")]
        [string]
        $Network,
		[parameter(Position = 0, ParameterSetName="AddressRange")]
		[parameter(Position = 0, ParameterSetName="Subnet")]
		[ValidatePattern("\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b")]
		[string]
        $StartAddress,
        [parameter(Position = 1, ParameterSetName="AddressRange")]
		[string]
        $EndAddress,
        [parameter(Position = 1, ParameterSetName="Subnet")]
		[string]
        $Subnet,
		[switch]
        $ResolveHost,
		[switch]
        $TCPScan,
        [switch]
        $UDPScan,
		[int]
        $UDPTimeOut = 5000,
		[int[]]
        $Ports = @(21,22,23,53,69,71,80,88,110,139,111,389,443,445,1080,1433,1434,1521,2001,2049,3001,3128,3306,3389,5222,5555,5801,5900,5901,6667,6868,7777,7878,8080),
		[int]
        $TimeOut = 100
	)
	Begin {
		$ping = New-Object System.Net.Networkinformation.Ping
		$hosts = @()
        $ret = @()
        if ($PSCmdlet.ParameterSetName -eq "AddressList") {
            $hosts = $AddressList
        } else {
            if ($PSCmdlet.ParameterSetName -eq "Network") {
                if ($Network.IndexOf("-") -ne -1){
                    $StartAddress = $Network.Split('-')[0]
                    $EndAddr = $Network.Split('-')[1]
                    if ($EndAddr.StartsWith(".")){
                        $EndAddr = $EndAddr.Substring(1)
                    }
                    $t = 3 - $EndAddr.Split('.').Count
                    $EndAddr = $StartAddress.Split('.')[0..$t] + $EndAddr.Split('.')
                    $EndAddress = $EndAddr[0]
                    for ($i = 1; $i -lt 4; $i++) {
                        $EndAddress += "." + $EndAddr[$i]
                    }
                } else {
                    $ipBinary = toBinary([String]($Network.Split('\').Split('/')[0]))
                    $Subnet = [int]($Network.Split('\').Split('/')[1])
                    $StartAddress = toDottedDecimal($ipBinary.substring(0,$Subnet).padright(31,"0") + "1")
			        $EndAddress = toDottedDecimal($ipBinary.substring(0,$Subnet).padright(31,"1") + "0")
                }
            } elseif ($PSCmdlet.ParameterSetName -eq "AddressRange") {
			    if ($Subnet) {
				    $ipBinary = toBinary($StartAddress)
				    if ($Subnet.StartsWith("/") -or $Subnet.StartsWith("\")) {
					    $Subnet = $Subnet.Substring(1)
				    }
                    $Subnet = [int]$Subnet
				    $StartAddress = toDottedDecimal($ipBinary.substring(0,$Subnet).padright(31,"0") + "1")
				    $EndAddress = toDottedDecimal($ipBinary.substring(0,$Subnet).padright(31,"1") + "0")
			    }
            }
            if (!$EndAddress) {
			    $hosts += $StartAddress
		    } else {
                $Start = [convert]::ToUInt32( $(toBinary($StartAddress)), 2 )
                $End = [convert]::ToUInt32( $(toBinary($EndAddress)), 2)
		        for ($i = $start; $i -le $End; $i++){
                    $t = [convert]::toString($i,2).padleft(32,"0")
                    $hosts += toDottedDecimal( $t )
		        }
            }
        }
	}
	Process {
		for ($n = 0; $n -lt $hosts.Count; $n++) {
            $h = $hosts[$n]
			$d = $h.Split(".")[3]
			if ($EndAddress) {
				write-progress -activity PingSweep -status "$h" -percentcomplete (($n/$hosts.Count) * 100)
			}
			$pingStatus = $ping.Send("$h",$TimeOut)
			if ($pingStatus.Status -eq "Success") {
				if($ResolveHost) {
					if ($EndAddress){
						write-progress -activity ResolveHost -status "$h" -percentcomplete (($n/$hosts.Count)  * 100) -Id 1
					}
					$getHostEntry = [Net.DNS]::BeginGetHostEntry($pingStatus.Address, $null, $null)
				}
                if ($TCPScan -or $UDPScan) {
				    for ($i = 1; $i -le $ports.Count;$i++) {
					    $port = $ports[($i-1)]
					    write-progress -activity PortScan -status "$h" -percentcomplete (($i/($Ports.Count)) * 100) -Id 2
					    if ($TCPScan) {
                            $OpenTCPPorts = @()
                            $ClosedTCPPorts = @()
						    $client = New-Object System.Net.Sockets.TcpClient
						    $beginConnect = $client.BeginConnect($pingStatus.Address,$port,$null,$null)
						    if ($client.Connected) {
							    $OpenTCPPorts += $port
						    } else {
							    # Wait
							    Start-Sleep -Milli $TimeOut
							    if($client.Connected) {
								    $OpenTCPPorts += $port
							    } else {
								    $ClosedTCPPorts += $port
							    }
						    }
						    $client.Close()
					    }
					    if ($UDPScan) {
                            $OpenUDPPorts = @()
                            $ClosedUDPPorts = @()
						    $client = new-Object system.Net.Sockets.Udpclient
						    $client.client.ReceiveTimeout = $UDPTimeOut
						    $client.Connect($pingStatus.Address,$port)
						    $a = new-Object System.Text.ASCIIEncoding
						    $byte = $a.GetBytes("$(Get-Date)")
						    [void]$client.Send($byte,$byte.length)
						    $remoteendpoint = New-Object system.net.ipendpoint([system.net.ipaddress]::Any,0)
						    Try {
							    $receivebytes = $client.Receive([ref]$remoteendpoint) 
							    [string]$returndata = $a.GetString($receivebytes)
							    If ($returndata) {
								    $OpenUDPPorts += $port
							    }
						    } Catch {
							    If ($Error[0].ToString() -match "\bRespond after a period of time\b") {
								    $OpenUDPPorts += $port
							    } ElseIf ($Error[0].ToString() -match "forcibly closed by the remote host" ) { 
								    $ClosedUDPPorts += $port
							    } Else {
                                    Write-Host $Error[0].ToString()
                                }
						    } Finally {
							    $client.close()
						    }
					    } 
				    }
                }
			}
			if($ResolveHost) {
				$hostName = ([Net.DNS]::EndGetHostEntry([IAsyncResult]$getHostEntry)).HostName
			}
			# Return Object
			$ret += New-Object PSObject -Property @{
				IPAddress = "$h";
				HostName = $hostName;
				OpenTCPPorts = $OpenTCPPorts;
				ClosedTCPPorts = $ClosedTCPPorts;
                OpenUDPPorts = $OpenUDPPorts;
				ClosedUDPPorts = $ClosedUDPPorts;
			}
		}
	}
	End {
        return $ret
	}
}
